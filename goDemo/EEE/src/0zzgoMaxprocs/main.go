package main

//import (
//	"fmt"
//	"runtime"
//	"sync"
//)
//
//func main() {
//	runtime.GOMAXPROCS(2)
//	var wg sync.WaitGroup
//	wg.Add(2)
//
//	fmt.Println("Starting Go Routines")
//	go func() {
//		//time.Sleep(2 * time.Microsecond)
//		defer wg.Done()
//		for char := 'a'; char < 'a'+26; char++ {
//			fmt.Printf("%c", char)
//		}
//	}()
//
//	go func() {
//		defer wg.Done()
//		for number := 1; number < 23; number++ {
//			fmt.Printf("%d", number)
//		}
//	}()
//	fmt.Println("waiting To finish")
//	wg.Wait()
//	fmt.Println("\n Terminating program")
//}

/*
为了理解如何通过go编写出更简单 难出错的并发程序  我们首先需要去理解 什么是并发程序
和并发程序的结果是什么 这两个问题 本文着重于讲并发是什么 协程的角色是什么 环境变量GOMAXPROCS和运行时函数
如何影响Go语言的程序的执行

####进程和线程
当我们运行一个应用  比如上淘宝用的浏览器 操作系统会为这个应用创建一个进程 进程的任务就像是一个容器 为这个应用运行的时候使用和管理资源
这些资源包括内存地址空间 指向文件句柄 设备和线程

线程是执行的一部分 它会被操作系统调度去执行进程里面被我们在函数里面实现的代码 一个进程开始于一个线程
也叫作 主线程 当这个线程 结束整个进程也会随之结束  这是因为主线程是应用程序的来源 主线程可以反过来创建更多的线程
而这些线程还能创建更多的线程

操作系统可以调度一个线程在一个可用的处理器上面执行 而不管处理这个线程的父线程在哪个处理器上面执行
每个操作系统都有自己的调度算法 并不是特定一种 来决定最好的方式 让我们开发并行程序  并且这些算法将会随着操作系统的每次升级
发生改变 这个需要我们注意

####协程和并行
go语言里面任何函数或者方法都可以创建一个协程 我们可以认为主方法执行起来是一个协程 然而go
的运行时并没有启动这个协程 协程可以认为是轻量级的 因为它们占用很小的内存和资源 并且它初始化的栈空间
也很小

操作系用调度可用的处理器来执行线程 go的运行时会通过一个操作系统线程来调度协程 默认情况下
go的运行时会分配一个逻辑处理器来执行代码里面定义的全部协程 甚至通过这个逻辑处理器和操作系统线程
成百上千协程可以被并发的高效迅速地调用执行 不建议添加更多的逻辑处理器 如果你想并行运行这些协程
go提供了通过GOMAXPROCS环境变量或运行时函数来增加逻辑处理器

并发不是并行 并行是在多核处理器不同的核同时并行执行两个或者两个以上的线程 如果你配置运行时的逻辑
处理器多于1个 调度器将会在这些逻辑处理器上面分配协程 这样做的结果就是在不同的操作系统线程上面执行多个协程
然而 想要真正的实现并执行你的服务器必须是多核处理器 如果不是 即使go运行时被设置为需要多个逻辑处理器
协程仍会并发的在同一个处理器上面执行协程

####并发的例子
我们来创建一个小程序来展示go并发执行协程 这个例子我们是在默认设置下执行 默认设置是要使用一个逻辑处理器
import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	fmt.Println("Starting Go Routines")
	go func() {
		defer wg.Done()
		for char := 'a'; char < 'a'+26; char++ {
			fmt.Printf("%c ", char)
		}
	}()

	go func() {
		defer wg.Done()
		for number := 1; number < 23; number++ {
			fmt.Printf("%d ", number)
		}
	}()
	fmt.Println("waiting To finish")
	wg.Wait()
	fmt.Println("\n Terminating program")
}
本程序通过关键字go启动了两个协程 声明了两个匿名函数 第一个协程打印了小写英语字母 第二个打印； 1-22 这些数字
我们来看一下输出的结果 代码被并发的执行 一旦这两个协程被启动 主协程将会等待这两个协程执行结束
我们需要用这个方法否则一旦主协程运行结束 整个程序就结束了 waitgroup是一个不错的方法用来在不同的协程之间
通信是否完成
time.Sleep(1 * time.Microsecond)
我们在第一个协程里面增加了一秒钟的等待时间  调用sleep  导致了调度器交换了两个协程的执行顺序

####并行的例子
我们上面两个例子协程都是在并发执行 并不是并行的  我们改变一下代码来允许代码并行执行
我们需要做的就是为调度器增加一个逻辑处理器让它能够使用两个线程
runtime.GOMAXPROCS(2)
这一次我们运行这个程序将会得到不同的结果 我们看到协程这次真的是并行执行了 两个协程立刻开始运行 并且我们可以看到
两个都在竞争各自的输出结果

####结论
我们可以为调度器增加多个逻辑处理器 但这不意味着 我们必须这么做 随意添加逻辑处理器和并行的协程并不会一定
为你的程序提供更好的性能  要做好性能压力测试，确保修改Go运行时GOMAXPROCS一定能优化性能时再这么做。

在我们的应用里面创建并发的协程 这个问题最终将会导致我们的协程可以同时尝试访问同样的资源
读写共享资源一定要是原子性的 换句话说 读和写操作一定要在一个协程里面同时一个时刻只有一个操作被执行
否则我们就需要在代码里面创建临界条件  管道是go语言里面安全和优雅的编写并发程序的方法 它消除了编写竞争条件
可以使得开发并行程序更加有趣

















*/

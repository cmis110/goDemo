package main

import (
	"fmt"
)
//过滤用户数据是web应用安全的基础 它是验证数据合法性的过程 通过对所有输入数据进行过滤 可以避免恶意数据在程序中被误用
//大多数web应用程序的漏洞都是因为 没有对用户输入的数据进行恰当的过滤所引起的

//我们介绍的过滤数据分为三个步骤
//识别数据 搞清楚需要过滤的数据来自于哪里
//过滤数据 弄明白我们需要什么样的数据
//区分 已过滤及被污染的数据 如果存在 攻击数据那么保证过滤之后 我们可以使用更安全的数据

//识别数据
//识别数据作为第一步 是因为你不知道 数据是什么 它来自于哪里的前提下 你也就不能正确的过滤它
//这里的数据是指所有源自非代码内部提供的数据 例如 所有来自客户端的数据
//但客户端并不是唯一的外部数据源 数据库和第三方提供的接口数据等也可以是外部数据源

//由用户输入的数据 我们通过GO非常容易识别 Go通过 r.ParseForm之后
//把用户post和get的数据全部存放在了r.Form里面
//其他的输入要难识别得多 例如 r.Header中的很多元素是由客户端所操纵的
//常常很难确认其中的哪些元素 组成了输入 
//所以最好的方法是把里面的所有数据都看成是用户输入
//例如 r.Header.Get("Accept-Charset")这样的也看作是用户输入 虽然这些大多数是浏览器操纵的

//过滤数据
//在知道数据来源之后  就可以过滤它了  过滤是一个有点正式的术语
//主要目的是防止非法数据进入你的应用
//过滤数据有很多种方法 其中有一些安全性较差 最好的方法是把过滤看成是一个检查的过程
//在你使用数据之前 都检查一下 看它们是否符合合法数据的要求
//而且不要试图好心地去纠正非法数据
//而是要让用户按照你制定的规则去输入数据
//历史证明试图纠正非法数据往往会导致安全漏洞
//这里举个例子 最近建设银行系统升级之后 如果密码后两位是00 只要输入前四位就能登录系统
//过滤数据主要采用如下的一些库来操作
//strconv包下面的字符串转化相关的函数 因为从request中的r.Form返回的就是字符串
//而有些时候我们需要将其转化成整数浮点数 Atoi ParseBool ParseFloat ParseInt等函数就可以派上用场了
//string包下面的一些过滤函数 Trim ToLower ToTitle等函数 能够帮助我们按照指定的格式获取信息
//regexp包 用来处理一些复杂的需求 例如判定输入是否是email生日之类的
//过滤数据除了检查验证之外 在特殊时期 还可以采用白名单 即假定你在检查的数据都是非法的 除非能证明他是合法的
//使用这个方法 如果出现错误 只会导致把合法的数据当成是非法的 而不会是相反 尽管 我们不想犯错 但这样总比把非法数据当成合法数据要安全的多

//区分过滤数据
//如果完成了上面的两步 数据过滤的工作基本就完成了 但是在编写web应用的时候
//我们还需要区分已过滤和被污染的数据 因为这样 可以保证 过滤数据的完整性 而不影响输入的数据
//我们约定把所有经过过滤的数据放入到一个叫全局的Map变量中CleanMap 这时需要两个重要的步骤来防止污染数据的注入
//每个请求都要初始化CleanMap为一个空Map
//加入检查及阻止来自外部数据源的变量命名为CleanMap

//接下俩让我们通过一个例子来巩固这些概念 请看下面这个表单
<form action="/whoami" method="post">
我是谁:
<select name="name">
	<option value="jony">jony</option>
	<option value="david">david</option>
	<option value="lily">lily</option>
<input type="submit"/>
</form>

//在处理这个表单的编程逻辑中 非常容易犯的错误是认为只能提交三个选择中的一个 其实攻击者可以，模拟post操作
//递交 name=attack这样的数据 所以在此时我们需要做类似白名单的处理

r.ParseForm()
name :=r.Form.Get("name")
CleanMap:=make(map[string]interface{},0)
if name=="jony"||name=="david"||name=="lily"{
CleanMap["name"]=name
}
//上面的代码中我们初始化了一个CleanMap的变量 当获取的name是指定的三个中的一个
//我们把数据存储到CleanMap中 这样 CleanMap["name"]中的数据是合法的
//从而在代码的其他部分使用它 当然我们还可以在else部分增加非法数据的处理

//上面的方法对于一组已知的合法值的数据很有效 但是对于过滤有
//一组已知合法字符组成的数据时就没有什么帮助 例如 你很可能需要一个用户名只能由字母或者数字组成
r.ParseForm()
username:=r.Form.Get("username")
CleanMap:=make(map[string]interface{},0)
if ok,_:=regexp.MatchString(^[a-zA-Z0-9].$,username);ok{
CleanMap["usename"]=username
}
//总结
//数据过滤在web安全中 起到一个基石的作用 大多数的安全问题 都是由于没有过滤数据和验证数据引起的
//例如前面小节的CSRF攻击 以及接下俩将要介绍的XSS攻击 SQL注入等都是没有认真地过滤数据引起的
//因此我们需要特别重视数据过滤这一块的处理

















